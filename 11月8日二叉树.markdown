#### 530. 二叉搜索树的最小绝对差

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> vec;
    void traverse(TreeNode* node){
        if(node == nullptr) return;
        traverse(node->left);
        vec.push_back(node->val);
        traverse(node->right);
    }
    int getMinimumDifference(TreeNode* root) {
        //大概思路应该是朝左右找，然后更新绝对值的最小值
        int min = INT32_MAX;
        vec.clear();
        traverse(root);
        for(int i = 1; i < vec.size(); ++i){
            if (vec[i] - vec[i-1] < min)
                min = vec[i] - vec[i-1];
        }
        return min;
    }
};
```

思路其实很简单，就是按照中序遍历生成有序数组，然后再去遍历。迭代法放到以后再学习。

#### 501. 二叉搜索树中的众数

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxCount;
    int count;
    TreeNode* pre;
    vector<int> result;
    void searchBST(TreeNode* cur){
        if(cur == nullptr) return;
        searchBST(cur->left);

        if(pre == nullptr)
            count = 1;
        else if(pre->val == cur->val)
            ++count;
        else
            count = 1;
        pre = cur;

        if(count == maxCount)
            result.push_back(cur->val);
        else if(count > maxCount){
            maxCount = count;
            result.clear();
            result.push_back(cur->val);
        }

        searchBST(cur->right);
        return;
    }
    vector<int> findMode(TreeNode* root) {
        maxCount = 0;
        count = 0;
        pre = nullptr;
        searchBST(root);
        return result;
    }
};
```

这个方法还是有点不好掌握，同时操作的变量太多了。每次处理的时候先处理count，再去处理result。

#### 236.二叉树的最近公共祖先

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;
        if(root->val == p->val || root->val == q->val) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if(left != nullptr && right != nullptr) return root;
        else if(left == nullptr) return right;
        else if(right == nullptr) return left;
        else return nullptr;
    }
};
```

这个还是有点难的，大体思路就是去左右子树去找q或p，找到了就带着root往上返回。如果出现祖先是p或q自己的情况，直接就可以返回了，因为这就表明其他分支没有q或p了，那么这个值可以一直返回到根。