#### 452.用最少数量的箭引爆气球

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b){
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int result = 1;
        for(int i = 1; i < points.size(); ++i){
            if(points[i-1][1] < points[i][0]){
                ++result;
            }
            else{
                points[i][1] = min(points[i-1][1], points[i][1]);
            }
        }    
        return result;
    }
};
```

我们只有在发现不重叠的新气球的时候，我们才拿出一支新箭。除此之外我们不断确定这支箭射出的位置，就是目前重叠下的最小的右区间。

#### 435.无重叠区间

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b){
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1;
        int end = intervals[0][1];
        for(int i = 1; i < intervals.size(); ++i){
            if(end <= intervals[i][0]){
                ++count;
                end = intervals[i][1];
            }
        }
        return intervals.size() - count;
    }
};
```

这道题大概思路就是，我们先求出重叠的区间数（几个互相重叠的区间为一组作为一个重叠区间），然后再用总的区间数减一下。那么我们按右区间排序后，每次都选取首个区间的右边界作为判断重叠的线，直到新的区间的左边界落到这条线外面，那我们就有一个新的重叠区间和之前的那些区间构成的重叠区间分离开来，因此count++。

#### 763.划分字母区间

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27] = {0};
        for(int i = 0; i < s.size(); ++i){
            hash[s[i] - 'a'] = i;
        }
        vector<int> result;
        int left = 0, right = 0;
        for(int i = 0; i < s.size(); ++i){
            right = max(right, hash[s[i] - 'a']);
            if(i == right){
                result.push_back(right - left + 1);
                left = i + 1;
            }
        }
        return result;
    }
};
```

这里说一下思路。遍历一遍字符串然后记录每个字母的最远位置。然后第二次遍历到每个位置都要去找当前的最远位置，直到游标i遇见了此最远位置。这就表明后面不会再出现前面的字母了，因此处理结果，然后修改left再继续。