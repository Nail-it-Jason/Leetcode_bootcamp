#### 226.翻转二叉树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

注意这道题前序和后序遍历都可以，中序遍历有的节点会翻转两次。其实就是先处理再递归还是先递归再处理，一个是自顶向下，一个是自底向上。

#### 101.对称二叉树

自己实现版

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool symmetric(TreeNode* left, TreeNode* right){
        if(left == nullptr && right == nullptr) return true;
        else if(left == nullptr || right == nullptr) return false;
        else if(left->val == right->val){
            return symmetric(left->right, right->left) &&
                   symmetric(left->left, right->right);
        }
        else return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;
        return symmetric(root->left, root->right);
    }
};
```

这里遇到了一些问题，首先是判断的是left->val==right->val而不是left\=\=right，另外之前没有添加第一个else if也就是如果出现一个空，一个非空的节点，那么会非法访问val值，后面补上了，但感觉不够优雅。

参考答案版

```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};

```

相比我的实现，参考答案展开了一些情况和变量，更加清晰。

#### 104.二叉树的最大深度

自己实现版

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count(TreeNode* node, int depth){
        if(node == nullptr) return depth;
        else{
            int a = count(node->left, depth + 1);
            int b = count(node->right, depth + 1);
            return (a > b ? a : b);
        }
    }
    int maxDepth(TreeNode* root) {
        int depth = 0;
        return count(root, depth);
    }
};
```

思路是设置一个变量带着走一遍递归，保存目前确认的深度，然后接着往下探。

参考答案版

```c++
class Solution {
public:
    int getdepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};

```

这个版本整合了depth变量，比我的更简洁。这里的累加其实是在int depth那一句里面做的。思维方式有点不同。

#### 111.二叉树的最小深度

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count(TreeNode* left, TreeNode* right, int depth){
        if(left == nullptr && right == nullptr) return depth;
        else if(left == nullptr)
            return count(right->left, right->right, depth + 1);
        else if(right == nullptr)
            return count(left->left, left->right, depth + 1);
        else{
            int a = count(left->left, left->right, depth + 1);
            int b = count(right->left, right->right, depth + 1);
            return (a < b ? a : b);
        }
    }
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        int depth = 1;
        return count(root->left, root->right, depth);
    }
};
```

要点，在写的时候遇到了一些问题，一开始count里面没添加中间的那两个else if，而且只有一个node参数，但是会遇到不对称的情况，遇到不对称的时候深度统计会在第一层就结束（因为遇到了空指针），但是实际的深度应该是一直到最底下。后来改了一下逻辑又发现深度总是比答案少1，后来又把depth初始值改成1，因为既然root非空的话，就应该至少是1。最后发现漏掉了空节点的情况，又补充上去了，才过了。

参考答案版

```c++
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};

```

在参考答案这里仍然用了单个节点参数，但是在函数内部区分了一下左右不对称的情况，其实某种意义上来讲也很类似。