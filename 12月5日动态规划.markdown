#### 115.不同的子序列

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1, 0));
        for(int i = 0; i <= s.size(); ++i){
            dp[i][0] = 1;
        }

        for(int j = 1; j <= t.size(); ++j){
            dp[0][j] = 0;
        }

        for(int i = 1; i <= s.size(); ++i){
            for(int j = 1; j <= t.size(); ++j){
                if(s[i - 1] == t[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else
                    dp[i][j] = dp[i - 1][j];
            }
        }

        return dp[s.size()][t.size()];
    }
};
```

分类讨论当前是否相等，如果相等的话，情况数等于使用i-1进行匹配的数量加不使用i-1进行匹配的数量，否则，情况数等于不使用i-1进行匹配的数量。

#### 583.两个字符串的删除操作

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        //dp[i][j]表示前i-1个word1的元素和前j-1个word2元素相同的步数
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        //如果第i-1个word1和第j-1个word2相同，则步数不增加
        //如果不同，那么要么在前i-2的基础上删除word1的一步，要么在前j-2的基础上
        //删除word2的一步，取最小。
        //dp[i][0]应该是i-1，dp[j][0]应该是j-1，dp[0][0]应该是0
        dp[0][0] = 0;
        for(int i = 1; i <= word1.size(); ++i){
            dp[i][0] = i;
        }
        for(int j = 1; j <= word2.size(); ++j){
            dp[0][j] = j;
        }
        for(int i = 1; i <= word1.size(); ++i){
            for(int j = 1; j <= word2.size(); ++j){
                if(word1[i - 1] == word2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

自己写的时候typo了，初始化第一行的时候写成了```dp[j][0]```而不是```dp[0][j]```。其他都没问题。

#### 72.编辑距离

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};

```

这题首先删除和添加等价，和上一题类似，而替换则是在左上方结果的基础上多一步替换使得当前考察的两个元素相等。