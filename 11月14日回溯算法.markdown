#### 93.复原IP地址

```c++
class Solution {
public:
    string path;
    vector<string> ans;
    bool isValid(string& s, int start, int end){
        if(start > end) return false;
        if(s[start] == '0' && start != end){
            return false;
        }
        int num = 0;
        for(int i = start; i <= end; ++i){
            num = num * 10 + (s[i] - '0');
            if(num > 255) return false;
        }
        
        return true;
    }
    void backtrack(string& s, int start, int pointNum){
        if(pointNum == 3){
            if(isValid(s, start, s.size() - 1)){
                ans.push_back(s);
            }
            return;
        }
        for(int i = start; i < s.size(); ++i){
            if(isValid(s, start, i)){
                s.insert(s.begin()+i+1, '.');
                pointNum++;
                backtrack(s, i+2, pointNum);
                pointNum--;
                s.erase(s.begin()+i+1);
            }
            else
                break;
        }

    }
    vector<string> restoreIpAddresses(string s) {
        backtrack(s, 0, 0);
        return ans;
    }
};
```

这里有几个关键点，我们的回溯要记录一个“深度量”，在这里我们使用字符里的点数记录深度。除此之外，还要注意插入删除以及递归的角标位置。

#### 78.子集

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> ans;
    void backtrack(vector<int>& nums, int start){
        ans.push_back(path);
        if(start >= nums.size()) return;
        for(int i = start; i < nums.size(); ++i){
            path.push_back(nums[i]);
            backtrack(nums, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums, 0);
        return ans;
    }
};
```

注意这里我们不是到根部才压值，而是每次backtrack进来都压值。剩下的步骤保持。

#### 90.子集II

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> ans;
    void backtrack(vector<int>& nums, int start, vector<bool>& used){
        ans.push_back(path);
        for(int i = start; i < nums.size(); ++i){
            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false)
                continue;
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, i+1, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtrack(nums, 0, used);
        return ans;
    }
};
```

多个去重，使用used数组完成。另外注意几个细节，需要先排序，否则达不到去重效果，另外，还需要初始化一下used，否则不知道大小会越界。