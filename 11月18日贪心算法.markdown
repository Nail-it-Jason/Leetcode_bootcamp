#### 122.买卖股票的最佳时机II

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for(int i = 1; i < prices.size(); ++i){
            if(prices[i] > prices[i-1])
                ans += (prices[i] - prices[i-1]);
        }
        return ans;
    }
};
```

这也叫中等题。。。？

#### 55.跳跃游戏

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 1) return true;
        int cover = 0;
        for(int i = 0; i <= cover && i < nums.size(); ++i){
            cover = max(cover, nums[i] + i);
            if(cover >= nums.size() - 1) return true;
        }
        return false;
    }
};
```

这题我一开始写的是for循环里```i < nums.size()```，但是这样是不完善的，因为这样的话i一定会走到头，但是实际情况是我们不一定会走到头。

#### 45.跳跃游戏II

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int step = 0;
        int cover = 0;
        int nextcover = 0;
        for(int i = 0; i < nums.size(); ++i){
            nextcover = max(nextcover, i + nums[i]);
            if(i == cover){
                ++step;
                cover = nextcover;
                if(nextcover >= nums.size() - 1) break;
            }
        }
        return step;
    }
};
```

大概思想就是，nextcover负责处理我在当前cover下的每一个选择所能到达的最远距离。如果i走到了当前cover那么我们一定要真正的往前走一步了。

#### 1005.K次取反后最大化的数组和

```c++
class Solution {
public:
    static bool cmp(int& a, int& b){
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] < 0){
                --k;
                nums[i] = -nums[i];
            }
            if(k == 0) break;
        }
        while(k > 0){
            nums[nums.size() - 1] = -nums[nums.size() - 1];
            --k;
        }
        int sum = 0;
        for(auto& x : nums)
            sum += x;
        return sum;
    }
};
```

知道思路直接写，一遍过。首先按绝对值从大到小排序，然后先反转大的，如果k非常大，那就反复反转最后一个值，直到k的次数用完。

```if (K % 2 == 1) A[A.size() - 1] *= -1; ```其实不用写一个循环来反转，直接用奇偶性做一下就行。