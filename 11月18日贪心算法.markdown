#### 134. 加油站

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0, min = INT32_MAX;
        for(int i = 0; i < gas.size(); ++i){
            int rest = gas[i] - cost[i];
            curSum += rest;
            min = (curSum < min ? curSum : min);
        }
        //情况一 gas < cost 不可能
        if (curSum < 0) return -1;
        //情况二 剩的油，最小值>0
        if (min >= 0) return 0;
        //情况三 剩的油<0，从后往前补，哪里补平就从哪里开始
        for(int i = gas.size()-1; i >= 0; --i){
            int rest = gas[i] - cost[i];
            min += rest;
            if(min >= 0)
                return i;
        }
        return -1;
    }

};
```

要点：写的时候注意一下min的更新不是根据rest，而是根据curSum，因为就算rest是负的，但是上一波余量足够的话也不影响，

这道题其实充要条件就是看油量和耗油量的总量是否平衡，所以不需要两次循环

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0, min = INT32_MAX, minIdx = -1;
        for(int i = 0; i < gas.size(); ++i){
            int rest = gas[i] - cost[i];
            curSum += rest;
            if(curSum < min){
                minIdx = i;
                min = curSum;
            }
        }
        //情况一 gas < cost 不可能
        if (curSum < 0) return -1;
        //情况二 剩的油，最小值>0
        if (min >= 0) return 0;
        return (minIdx + 1) % gas.size();
    }

};
```

#### 135.分发糖果

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candysend(ratings.size(), 1);
        for(int i = 1; i < ratings.size(); ++i){
            if(ratings[i] > ratings[i-1])
                candysend[i] = candysend[i-1]+1;
        }
        for(int i = ratings.size() - 1; i >= 1; --i){
            if(ratings[i-1] > ratings[i])
                candysend[i-1] = max(candysend[i-1], candysend[i]+1);
        }
        for(int i = 1; i < candysend.size(); ++i)
            candysend[i] += candysend[i-1];
        return candysend[candysend.size() - 1];
    }
};
```

先从左往右，再从右往左，取两个结果的最大值就可以保证左边方向满足，右边方向也满足。感觉还不是特别理解。。

#### 860.柠檬水找零

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int changes[3] = {0};
        for(int i = 0; i < bills.size(); ++i){
            switch(bills[i]){
                case 5:
                    ++changes[0];
                    break;
                case 10:
                    ++changes[1];
                    if(changes[0] == 0) return false;
                    else{
                        --changes[0];
                    }
                    break;
                case 20:
                    ++changes[2];// 优先找10+5，不行再找3*5
                    if(changes[1] >= 1 && changes[0] >= 1){
                        --changes[0];
                        --changes[1];
                    }
                    else if(changes[0] >= 3){
                        changes[0] -= 3;
                    }
                    else return false;
                    break;
                default:
                    break;
            }
        }
        return true;
    }
};
```

这道题贪心的点在于我们优先保留五元的，优先用10元去找。

#### 406.根据身高重建队列

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b){
        if(a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> ans;
        for(int i = 0; i < people.size(); ++i){
            int index = people[i][1];
            ans.insert(ans.begin()+index, people[i]);
        }
        return ans;
    }
};
```

先按照身高排序，然后相同身高前面人数少的优先。然后直接插入就可以了。

```c++
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```

也可以使用链表，这样插入每次只需要$O(n)$。