#### 121.买卖股票的最佳时机

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //dp[i][0]表示第i天持有股票所得钱数，dp[i][1]表示第i天不持有股票所得钱数
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); ++i){
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

嗯，dp相当于我们的钱袋子了，如果买了股票的话，钱袋子是负数，直到我们把股票卖了才会入账。第i天持有股票的话，那么可能是前一天没有买卖直接过来的，也可能是前一天才买的。第i天不持有股票的话，可能是前一天就已经不持有了，也可能是卖掉了，入账了。

#### 122.买卖股票的最佳时机II

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for(int i = 1; i < prices.size(); ++i){
            if(prices[i] > prices[i-1])
                ans += (prices[i] - prices[i-1]);
        }
        return ans;
    }
};
```

这里是已经实现过的贪心算法。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < len; ++i){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

动态规划的思想和上一题差不多。

#### 123.买卖股票的最佳时机III

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        //0-4:不操作，第一次持有，第一次不持有，第二次持有，第二次不持有
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i = 1; i < prices.size(); ++i){
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

注意这里分了很多个状态，状态沿着0-4去转移，每次只需要考察相邻的状态，换句话说，状态是不会一下子跳两个的。