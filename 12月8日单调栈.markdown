#### 739.每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> ans(temperatures.size(), 0);
        for(int i = 0; i < temperatures.size() - 1; ++i){
            for(int j = i + 1; j < temperatures.size(); ++j){
                if(temperatures[j] > temperatures[i]){
                    ans[i] = j - i;
                    break;
                }
            }
        }
        return ans;
    }
};
```

暴力解法，超时了。

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st; //从栈顶到栈低保证递增顺序
        vector<int> ans(temperatures.size(), 0);
        if(temperatures.size() == 1) return ans;

        st.push(0);
        for(int i = 1; i < temperatures.size(); ++i){
            if(!st.empty() && temperatures[i] <= temperatures[st.top()]){
                st.push(i);
                continue;
            }
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){
                ans[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return ans;
    }
};
```

使用单调栈的思路写了一下。只有保证栈顶到栈底是单调不减的，我们在遇到比栈顶元素大的时候才可以去做计算。

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

这个写法更清晰一些。

#### 496.下一个更大元素I

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> ans(nums1.size(), -1);

        unordered_map<int, int> umap;

        for(int i = 0; i < nums1.size(); ++i){
            umap[nums1[i]] = i;
        }

        st.push(0);

        for(int i = 1; i < nums2.size(); ++i){
            if(nums2[i] <= nums2[st.top()]){
                st.push(i);
            }
            else{
                while(!st.empty() && nums2[i] > nums2[st.top()]){
                    if(umap.find(nums2[st.top()]) != umap.end()){// 找到了
                        ans[umap[nums2[st.top()]]] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return ans;
    }
};
```

注意这里的umap，我们对nums2一样做单调栈处理，但是区别是，我们需要栈顶元素的值，并映射到nums1的下标，并存入ans相同下标的位置。所以umap是连接了nums2和nums1的工具，取得key是nums2和nums1的公共取值，然后可以搜索到nums1的下标。

#### 503.下一个更大元素II

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> nums1(nums.begin(), nums.end());
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        vector<int> ans(nums.size(), -1);
        stack<int> st;
        st.push(0);

        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] <= nums[st.top()])
                st.push(i);
            else{
                while(!st.empty() && nums[i] > nums[st.top()]){
                    ans[st.top()] = nums[i];
                    st.pop();
                }
                st.push(i);
            }
        }

        ans.resize(nums.size() / 2);
        return ans;
    }
};
```

这种情况如果可以循环的话，只需要很机智的给数组复制一份就可以了。注意resize是没有返回值的。
